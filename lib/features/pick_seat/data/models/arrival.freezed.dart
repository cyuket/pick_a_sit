// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'arrival.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$ArrivalTypeTearOff {
  const _$ArrivalTypeTearOff();

  _InTimeArrivalType inTime() {
    return const _InTimeArrivalType();
  }

  _PendingArrivalType pending() {
    return const _PendingArrivalType();
  }

  _LateArrivalType late() {
    return const _LateArrivalType();
  }
}

/// @nodoc
const $ArrivalType = _$ArrivalTypeTearOff();

/// @nodoc
mixin _$ArrivalType {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() inTime,
    required TResult Function() pending,
    required TResult Function() late,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? inTime,
    TResult Function()? pending,
    TResult Function()? late,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? inTime,
    TResult Function()? pending,
    TResult Function()? late,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InTimeArrivalType value) inTime,
    required TResult Function(_PendingArrivalType value) pending,
    required TResult Function(_LateArrivalType value) late,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_InTimeArrivalType value)? inTime,
    TResult Function(_PendingArrivalType value)? pending,
    TResult Function(_LateArrivalType value)? late,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InTimeArrivalType value)? inTime,
    TResult Function(_PendingArrivalType value)? pending,
    TResult Function(_LateArrivalType value)? late,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ArrivalTypeCopyWith<$Res> {
  factory $ArrivalTypeCopyWith(
          ArrivalType value, $Res Function(ArrivalType) then) =
      _$ArrivalTypeCopyWithImpl<$Res>;
}

/// @nodoc
class _$ArrivalTypeCopyWithImpl<$Res> implements $ArrivalTypeCopyWith<$Res> {
  _$ArrivalTypeCopyWithImpl(this._value, this._then);

  final ArrivalType _value;
  // ignore: unused_field
  final $Res Function(ArrivalType) _then;
}

/// @nodoc
abstract class _$InTimeArrivalTypeCopyWith<$Res> {
  factory _$InTimeArrivalTypeCopyWith(
          _InTimeArrivalType value, $Res Function(_InTimeArrivalType) then) =
      __$InTimeArrivalTypeCopyWithImpl<$Res>;
}

/// @nodoc
class __$InTimeArrivalTypeCopyWithImpl<$Res>
    extends _$ArrivalTypeCopyWithImpl<$Res>
    implements _$InTimeArrivalTypeCopyWith<$Res> {
  __$InTimeArrivalTypeCopyWithImpl(
      _InTimeArrivalType _value, $Res Function(_InTimeArrivalType) _then)
      : super(_value, (v) => _then(v as _InTimeArrivalType));

  @override
  _InTimeArrivalType get _value => super._value as _InTimeArrivalType;
}

/// @nodoc

class _$_InTimeArrivalType implements _InTimeArrivalType {
  const _$_InTimeArrivalType();

  @override
  String toString() {
    return 'ArrivalType.inTime()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _InTimeArrivalType);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() inTime,
    required TResult Function() pending,
    required TResult Function() late,
  }) {
    return inTime();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? inTime,
    TResult Function()? pending,
    TResult Function()? late,
  }) {
    return inTime?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? inTime,
    TResult Function()? pending,
    TResult Function()? late,
    required TResult orElse(),
  }) {
    if (inTime != null) {
      return inTime();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InTimeArrivalType value) inTime,
    required TResult Function(_PendingArrivalType value) pending,
    required TResult Function(_LateArrivalType value) late,
  }) {
    return inTime(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_InTimeArrivalType value)? inTime,
    TResult Function(_PendingArrivalType value)? pending,
    TResult Function(_LateArrivalType value)? late,
  }) {
    return inTime?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InTimeArrivalType value)? inTime,
    TResult Function(_PendingArrivalType value)? pending,
    TResult Function(_LateArrivalType value)? late,
    required TResult orElse(),
  }) {
    if (inTime != null) {
      return inTime(this);
    }
    return orElse();
  }
}

abstract class _InTimeArrivalType implements ArrivalType {
  const factory _InTimeArrivalType() = _$_InTimeArrivalType;
}

/// @nodoc
abstract class _$PendingArrivalTypeCopyWith<$Res> {
  factory _$PendingArrivalTypeCopyWith(
          _PendingArrivalType value, $Res Function(_PendingArrivalType) then) =
      __$PendingArrivalTypeCopyWithImpl<$Res>;
}

/// @nodoc
class __$PendingArrivalTypeCopyWithImpl<$Res>
    extends _$ArrivalTypeCopyWithImpl<$Res>
    implements _$PendingArrivalTypeCopyWith<$Res> {
  __$PendingArrivalTypeCopyWithImpl(
      _PendingArrivalType _value, $Res Function(_PendingArrivalType) _then)
      : super(_value, (v) => _then(v as _PendingArrivalType));

  @override
  _PendingArrivalType get _value => super._value as _PendingArrivalType;
}

/// @nodoc

class _$_PendingArrivalType implements _PendingArrivalType {
  const _$_PendingArrivalType();

  @override
  String toString() {
    return 'ArrivalType.pending()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _PendingArrivalType);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() inTime,
    required TResult Function() pending,
    required TResult Function() late,
  }) {
    return pending();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? inTime,
    TResult Function()? pending,
    TResult Function()? late,
  }) {
    return pending?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? inTime,
    TResult Function()? pending,
    TResult Function()? late,
    required TResult orElse(),
  }) {
    if (pending != null) {
      return pending();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InTimeArrivalType value) inTime,
    required TResult Function(_PendingArrivalType value) pending,
    required TResult Function(_LateArrivalType value) late,
  }) {
    return pending(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_InTimeArrivalType value)? inTime,
    TResult Function(_PendingArrivalType value)? pending,
    TResult Function(_LateArrivalType value)? late,
  }) {
    return pending?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InTimeArrivalType value)? inTime,
    TResult Function(_PendingArrivalType value)? pending,
    TResult Function(_LateArrivalType value)? late,
    required TResult orElse(),
  }) {
    if (pending != null) {
      return pending(this);
    }
    return orElse();
  }
}

abstract class _PendingArrivalType implements ArrivalType {
  const factory _PendingArrivalType() = _$_PendingArrivalType;
}

/// @nodoc
abstract class _$LateArrivalTypeCopyWith<$Res> {
  factory _$LateArrivalTypeCopyWith(
          _LateArrivalType value, $Res Function(_LateArrivalType) then) =
      __$LateArrivalTypeCopyWithImpl<$Res>;
}

/// @nodoc
class __$LateArrivalTypeCopyWithImpl<$Res>
    extends _$ArrivalTypeCopyWithImpl<$Res>
    implements _$LateArrivalTypeCopyWith<$Res> {
  __$LateArrivalTypeCopyWithImpl(
      _LateArrivalType _value, $Res Function(_LateArrivalType) _then)
      : super(_value, (v) => _then(v as _LateArrivalType));

  @override
  _LateArrivalType get _value => super._value as _LateArrivalType;
}

/// @nodoc

class _$_LateArrivalType implements _LateArrivalType {
  const _$_LateArrivalType();

  @override
  String toString() {
    return 'ArrivalType.late()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _LateArrivalType);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() inTime,
    required TResult Function() pending,
    required TResult Function() late,
  }) {
    return late();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? inTime,
    TResult Function()? pending,
    TResult Function()? late,
  }) {
    return late?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? inTime,
    TResult Function()? pending,
    TResult Function()? late,
    required TResult orElse(),
  }) {
    if (late != null) {
      return late();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InTimeArrivalType value) inTime,
    required TResult Function(_PendingArrivalType value) pending,
    required TResult Function(_LateArrivalType value) late,
  }) {
    return late(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_InTimeArrivalType value)? inTime,
    TResult Function(_PendingArrivalType value)? pending,
    TResult Function(_LateArrivalType value)? late,
  }) {
    return late?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InTimeArrivalType value)? inTime,
    TResult Function(_PendingArrivalType value)? pending,
    TResult Function(_LateArrivalType value)? late,
    required TResult orElse(),
  }) {
    if (late != null) {
      return late(this);
    }
    return orElse();
  }
}

abstract class _LateArrivalType implements ArrivalType {
  const factory _LateArrivalType() = _$_LateArrivalType;
}
